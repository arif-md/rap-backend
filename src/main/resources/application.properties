spring.application.name=backend

# ===========================================================================
# Azure SQL Database Configuration with Managed Identity (Passwordless)
# ===========================================================================
# Connection string format varies based on deployment mode:
#
# PUBLIC ACCESS MODE (current):
#   - Endpoint: <server>.database.windows.net (public DNS)
#   - Authentication: Managed Identity (recommended) or SQL authentication
#   - Firewall: "Allow Azure Services" rule enabled
#   - Format: jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#
# PRIVATE ENDPOINT MODE (future - requires ENABLE_VNET_INTEGRATION=true):
#   - Endpoint: <server>.privatelink.database.windows.net (private DNS)
#   - Authentication: Managed Identity (recommended) or SQL authentication
#   - Network: Private IP within VNet (10.0.2.x)
#   - Format: jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#   - Note: Same JDBC URL works for both modes - DNS resolution changes based on VNet config
#
# MANAGED IDENTITY AUTHENTICATION (Azure - recommended):
spring.datasource.url=${AZURE_SQL_CONNECTIONSTRING:jdbc:sqlserver://localhost:1433;databaseName=rapdb;encrypt=true;trustServerCertificate=true;}
# No username/password needed when using Managed Identity in Azure
# The spring-cloud-azure-starter-jdbc-mssql library handles token acquisition automatically

# SQL AUTHENTICATION (fallback - local development only):
# Uncomment for local Docker testing with SQL Server container
#spring.datasource.username=${AZURE_SQL_USERNAME:sa}
#spring.datasource.password=${AZURE_SQL_PASSWORD:YourStrong@Passw0rd}

spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Connection Pool Settings (HikariCP - default in Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===========================================================================
# MyBatis Configuration
# ===========================================================================
# Mapper XML files location
mybatis.mapper-locations=classpath:mapper/**/*.xml
# Type aliases package (allows using simple class names in mappers)
mybatis.type-aliases-package=x.y.z.backend.domain.model
# Type handlers package (for custom type conversions like UUID)
mybatis.type-handlers-package=x.y.z.backend.config
# Enable camelCase mapping (database_column -> databaseColumn)
mybatis.configuration.map-underscore-to-camel-case=true
# Show SQL in logs (disable in production)
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# ===========================================================================
# Flyway Database Migration Configuration
# ===========================================================================
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true
# Clean schema on startup - DANGEROUS! Only for development
# spring.flyway.clean-disabled=false

# ===========================================================================
# Spring Boot Actuator Configuration
# ===========================================================================
management.endpoints.web.exposure.include=health,info,flyway
management.endpoint.health.show-details=when-authorized
management.health.db.enabled=true

# ===========================================================================
# Transaction Management (without JPA/Hibernate)
# ===========================================================================
# Spring JDBC transaction manager is auto-configured when using MyBatis
# No additional configuration needed for basic transactions

# ===========================================================================
# Logging Configuration
# ===========================================================================
logging.file.name=/tmp/application.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.level.x.y.z.backend=DEBUG
logging.level.org.mybatis=DEBUG
logging.level.com.microsoft.sqlserver.jdbc=INFO
logging.level.org.springframework.jdbc=DEBUG
logging.level.org.springframework.transaction=DEBUG
logging.level.org.springframework.security=DEBUG

# ===========================================================================
# OIDC OAuth2 Client Configuration (External Authentication Provider)
# ===========================================================================
# Two configuration modes supported:
# 
# MODE 1 - Local Development (issuer-uri discovery):
#   Set OIDC_PROVIDER_ISSUER_URI and Spring auto-discovers all endpoints
#   Example: OIDC_PROVIDER_ISSUER_URI=http://localhost:9090/realms/raptor
#
# MODE 2 - Azure Production (explicit endpoints):
#   Set individual endpoint URLs: OIDC_AUTHORIZATION_ENDPOINT, OIDC_TOKEN_ENDPOINT, etc.
#   Used when issuer-uri is not accessible or endpoints need explicit configuration
#
# Spring uses issuer-uri if available, falls back to explicit endpoints
# ===========================================================================

# OIDC Provider Details
# Local mode: Keycloak auto-discovery via issuer-uri
spring.security.oauth2.client.provider.oidc-provider.issuer-uri=${OIDC_PROVIDER_ISSUER_URI:}

# Azure mode: Explicit endpoint configuration (fallback when issuer-uri is empty)
spring.security.oauth2.client.provider.oidc-provider.authorization-uri=${OIDC_AUTHORIZATION_ENDPOINT:${OIDC_PROVIDER_ISSUER_URI:http://localhost:9090/realms/raptor}/protocol/openid-connect/auth}
spring.security.oauth2.client.provider.oidc-provider.token-uri=${OIDC_TOKEN_ENDPOINT:${OIDC_PROVIDER_ISSUER_URI:http://localhost:9090/realms/raptor}/protocol/openid-connect/token}
spring.security.oauth2.client.provider.oidc-provider.user-info-uri=${OIDC_USER_INFO_ENDPOINT:${OIDC_PROVIDER_ISSUER_URI:http://localhost:9090/realms/raptor}/protocol/openid-connect/userinfo}
spring.security.oauth2.client.provider.oidc-provider.jwk-set-uri=${OIDC_JWK_SET_URI:${OIDC_PROVIDER_ISSUER_URI:http://localhost:9090/realms/raptor}/protocol/openid-connect/certs}
spring.security.oauth2.client.provider.oidc-provider.user-name-attribute=preferred_username

# OAuth2 Client Registration (Your Application)
spring.security.oauth2.client.registration.oidc-provider.client-id=${OIDC_CLIENT_ID:raptor-client}
spring.security.oauth2.client.registration.oidc-provider.client-secret=${OIDC_CLIENT_SECRET:changeme}
spring.security.oauth2.client.registration.oidc-provider.scope=openid,profile,email
spring.security.oauth2.client.registration.oidc-provider.redirect-uri={baseUrl}/auth/callback
spring.security.oauth2.client.registration.oidc-provider.client-name=Raptor OIDC Provider
spring.security.oauth2.client.registration.oidc-provider.authorization-grant-type=authorization_code

# ===========================================================================
# JWT Configuration (Your Application Tokens - Not OIDC Tokens)
# ===========================================================================
# JWT Signing Secret (MUST be strong and kept secret - store in Azure Key Vault for production)
jwt.secret=${JWT_SECRET:dGhpc2lzYXZlcnlzZWN1cmVzZWNyZXRrZXl0aGF0c2hvdWxkYmVyZXBsYWNlZGluYXp1cmU=}

# JWT Expiration (in minutes)
jwt.access-token-expiration-minutes=${JWT_ACCESS_TOKEN_EXPIRATION_MINUTES:15}

# Refresh Token Expiration (in days)
jwt.refresh-token-expiration-days=${JWT_REFRESH_TOKEN_EXPIRATION_DAYS:7}

# JWT Issuer (your backend URL)
jwt.issuer=${JWT_ISSUER:raptor-app}

# ===========================================================================
# Application Frontend Configuration
# ===========================================================================
# Frontend URL for redirects after successful authentication
frontend.url=${FRONTEND_URL:http://localhost:4200}

# ===========================================================================
# CORS Configuration
# ===========================================================================
# Allowed origins for CORS (comma-separated)
cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:4200,http://localhost:3000}

# ===========================================================================
# Session Configuration
# ===========================================================================
# Stateless session management (JWT-based, no server-side sessions)
spring.session.store-type=none
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=${USE_SECURE_COOKIES:false}
server.servlet.session.cookie.same-site=lax

# ===========================================================================
# Security Configuration
# ===========================================================================
# CSRF Protection (disabled for stateless JWT authentication)
# Will be configured in SecurityConfig.java

# ===========================================================================
# NOTES FOR AZURE DEPLOYMENT
# ===========================================================================
# When deploying to Azure Container Apps with Managed Identity:
# 
# 1. The following environment variables will be automatically set by Azure:
#    AZURE_SQL_CONNECTIONSTRING=jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#    
# 2. Remove or comment out AZURE_SQL_USERNAME and AZURE_SQL_PASSWORD in Azure
#    
# 3. Ensure the Container App's Managed Identity has been granted database access:
#    CREATE USER [<managed-identity-name>] FROM EXTERNAL PROVIDER;
#    ALTER ROLE db_datareader ADD MEMBER [<managed-identity-name>];
#    ALTER ROLE db_datawriter ADD MEMBER [<managed-identity-name>];
#    ALTER ROLE db_ddladmin ADD MEMBER [<managed-identity-name>];
#    
# 4. For local development, use Docker Compose with SQL Server container
#    and SQL authentication (current default values above)

