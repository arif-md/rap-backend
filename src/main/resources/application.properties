spring.application.name=backend

# ===========================================================================
# Azure SQL Database Configuration with Managed Identity (Passwordless)
# ===========================================================================
# Connection string format varies based on deployment mode:
#
# PUBLIC ACCESS MODE (current):
#   - Endpoint: <server>.database.windows.net (public DNS)
#   - Authentication: Managed Identity (recommended) or SQL authentication
#   - Firewall: "Allow Azure Services" rule enabled
#   - Format: jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#
# PRIVATE ENDPOINT MODE (future - requires ENABLE_VNET_INTEGRATION=true):
#   - Endpoint: <server>.privatelink.database.windows.net (private DNS)
#   - Authentication: Managed Identity (recommended) or SQL authentication
#   - Network: Private IP within VNet (10.0.2.x)
#   - Format: jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#   - Note: Same JDBC URL works for both modes - DNS resolution changes based on VNet config
#
# MANAGED IDENTITY AUTHENTICATION (Azure - recommended):
spring.datasource.url=${AZURE_SQL_CONNECTIONSTRING:jdbc:sqlserver://localhost:1433;databaseName=rapdb;encrypt=true;trustServerCertificate=true;}
# No username/password needed when using Managed Identity in Azure
# The spring-cloud-azure-starter-jdbc-mssql library handles token acquisition automatically

# SQL AUTHENTICATION (fallback - local development only):
# Uncomment for local Docker testing with SQL Server container
#spring.datasource.username=${AZURE_SQL_USERNAME:sa}
#spring.datasource.password=${AZURE_SQL_PASSWORD:YourStrong@Passw0rd}

spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Connection Pool Settings (HikariCP - default in Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===========================================================================
# MyBatis Configuration
# ===========================================================================
# Mapper XML files location
mybatis.mapper-locations=classpath:mapper/**/*.xml
# Type aliases package (allows using simple class names in mappers)
mybatis.type-aliases-package=x.y.z.backend.domain.model
# Type handlers package (for custom type conversions like UUID)
mybatis.type-handlers-package=x.y.z.backend.config
# Enable camelCase mapping (database_column -> databaseColumn)
mybatis.configuration.map-underscore-to-camel-case=true
# Show SQL in logs (disable in production)
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# ===========================================================================
# Flyway Database Migration Configuration
# ===========================================================================
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true
# Clean schema on startup - DANGEROUS! Only for development
# spring.flyway.clean-disabled=false

# ===========================================================================
# Spring Boot Actuator Configuration
# ===========================================================================
management.endpoints.web.exposure.include=health,info,flyway
management.endpoint.health.show-details=when-authorized
management.health.db.enabled=true

# ===========================================================================
# Transaction Management (without JPA/Hibernate)
# ===========================================================================
# Spring JDBC transaction manager is auto-configured when using MyBatis
# No additional configuration needed for basic transactions

# ===========================================================================
# Logging Configuration
# ===========================================================================
logging.file.name=/tmp/application.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.level.x.y.z.backend=DEBUG
logging.level.org.mybatis=DEBUG
logging.level.com.microsoft.sqlserver.jdbc=INFO
logging.level.org.springframework.jdbc=DEBUG
logging.level.org.springframework.transaction=DEBUG
logging.level.org.springframework.security=DEBUG

# ===========================================================================
# OIDC OAuth2 Client Configuration (External Authentication Provider)
# ===========================================================================
# CRITICAL: Explicit endpoint configuration to handle Docker networking
#
# Problem: Docker containers can't use 'localhost' - it resolves to container itself
# Solution: Use explicit endpoints with different hostnames for different purposes
#
# WORKS LOCALLY AND IN AZURE:
# - authorization-uri: Used by browser (localhost local, public URL in Azure)
# ===========================================================================
# OAuth2 / OIDC Configuration
# ===========================================================================
# Strategy: Use issuer-uri for auto-discovery + override authorization-uri
# 
# How it works:
# 1. Backend fetches discovery document from issuer-uri (host.docker.internal:9090)
# 2. Discovery document returns all endpoints as "localhost:9090" (due to frontendUrl)
# 3. Backend resolves localhost URLs using discovery, BUT authorization-uri is overridden
# 4. Browser uses overridden authorization-uri (localhost:9090 - publicly accessible)
# 5. Backend uses discovered endpoints which will be localhost:9090
#
# The KEY: Keycloak's frontendUrl makes discovery return localhost:9090 URLs
# Backend calling those URLs will fail UNLESS we also auto-discover with issuer-uri
# So the REAL solution: Use issuer-uri=host.docker.internal, which fetches discovery
# that contains localhost URLs, then backend needs to resolve localhost
#
# ACTUAL FINAL SOLUTION: Don't use issuer-uri at all, specify all endpoints explicitly
# ===========================================================================

# OIDC Provider Configuration - Explicit endpoints (no auto-discovery)
spring.security.oauth2.client.provider.oidc-provider.authorization-uri=${OIDC_AUTHORIZATION_ENDPOINT:http://localhost:9090/realms/raptor/protocol/openid-connect/auth}
spring.security.oauth2.client.provider.oidc-provider.token-uri=${OIDC_TOKEN_ENDPOINT:http://host.docker.internal:9090/realms/raptor/protocol/openid-connect/token}
spring.security.oauth2.client.provider.oidc-provider.user-info-uri=${OIDC_USER_INFO_ENDPOINT:http://host.docker.internal:9090/realms/raptor/protocol/openid-connect/userinfo}
spring.security.oauth2.client.provider.oidc-provider.jwk-set-uri=${OIDC_JWK_SET_URI:http://host.docker.internal:9090/realms/raptor/protocol/openid-connect/certs}
spring.security.oauth2.client.provider.oidc-provider.user-name-attribute=preferred_username

# OAuth2 Client Registration (Your Application with PKCE)
# PKCE (Proof Key for Code Exchange) is enabled for public clients (no client secret)
# This is more secure for applications that cannot safely store secrets
spring.security.oauth2.client.registration.oidc-provider.provider=oidc-provider
spring.security.oauth2.client.registration.oidc-provider.client-id=${OIDC_CLIENT_ID:raptor-client}
spring.security.oauth2.client.registration.oidc-provider.client-authentication-method=none
spring.security.oauth2.client.registration.oidc-provider.scope=openid,email
spring.security.oauth2.client.registration.oidc-provider.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
spring.security.oauth2.client.registration.oidc-provider.client-name=Raptor OIDC Provider
spring.security.oauth2.client.registration.oidc-provider.authorization-grant-type=authorization_code

# ===========================================================================
# JWT Configuration (Your Application Tokens - Not OIDC Tokens)
# ===========================================================================
# JWT Signing Secret (MUST be strong and kept secret - store in Azure Key Vault for production)
jwt.secret=${JWT_SECRET:dGhpc2lzYXZlcnlzZWN1cmVzZWNyZXRrZXl0aGF0c2hvdWxkYmVyZXBsYWNlZGluYXp1cmU=}

# JWT Expiration (in minutes) - Default for production/container environments
jwt.access-token-expiration-minutes=${JWT_ACCESS_TOKEN_EXPIRATION_MINUTES:15}

# Refresh Token Expiration (in days)
jwt.refresh-token-expiration-days=${JWT_REFRESH_TOKEN_EXPIRATION_DAYS:7}

# JWT Issuer (your backend URL)
jwt.issuer=${JWT_ISSUER:raptor-app}

# ===========================================================================
# Application Frontend Configuration
# ===========================================================================
# Frontend URL for redirects after successful authentication
frontend.url=${FRONTEND_URL:http://localhost:4200}

# ===========================================================================
# CORS Configuration
# ===========================================================================
# Allowed origins for CORS (comma-separated)
cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:4200,http://localhost:3000}

# ===========================================================================
# Session Configuration
# ===========================================================================
# Stateless session management (JWT-based, no server-side sessions)
spring.session.store-type=none
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=${USE_SECURE_COOKIES:false}
server.servlet.session.cookie.same-site=lax

# ===========================================================================
# Security Configuration
# ===========================================================================
# CSRF Protection (disabled for stateless JWT authentication)
# Will be configured in SecurityConfig.java

# ===========================================================================
# NOTES FOR AZURE DEPLOYMENT
# ===========================================================================
# When deploying to Azure Container Apps with Managed Identity:
# 
# 1. The following environment variables will be automatically set by Azure:
#    AZURE_SQL_CONNECTIONSTRING=jdbc:sqlserver://<server>.database.windows.net:1433;databaseName=<db>;authentication=ActiveDirectoryMSI;
#    
# 2. Remove or comment out AZURE_SQL_USERNAME and AZURE_SQL_PASSWORD in Azure
#    
# 3. Ensure the Container App's Managed Identity has been granted database access:
#    CREATE USER [<managed-identity-name>] FROM EXTERNAL PROVIDER;
#    ALTER ROLE db_datareader ADD MEMBER [<managed-identity-name>];
#    ALTER ROLE db_datawriter ADD MEMBER [<managed-identity-name>];
#    ALTER ROLE db_ddladmin ADD MEMBER [<managed-identity-name>];
#    
# 4. For local development, use Docker Compose with SQL Server container
#    and SQL authentication (current default values above)

# ===========================================================================
# Spring Boot DevTools Configuration (Hot Reload)
# ===========================================================================
# DevTools works with MyBatis when mapper resources are in the base classloader.
# See META-INF/spring-devtools.properties for exclusion configuration.

# Enable automatic restart when Java classes change
spring.devtools.restart.enabled=true

# Poll interval - how often to check for changes (milliseconds)
spring.devtools.restart.poll-interval=1000

# Quiet period - wait time after last change before restarting (milliseconds)
spring.devtools.restart.quiet-period=400

# Enable LiveReload for browser auto-refresh
spring.devtools.livereload.enabled=true

# Log restart reasons (helpful for debugging)
logging.level.org.springframework.boot.devtools=DEBUG
